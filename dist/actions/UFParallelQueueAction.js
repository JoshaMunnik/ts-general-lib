/**
 * @version 1
 * @author Josha Munnik
 * @copyright Copyright (c) 2022 Ultra Force Development
 * @license
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * <ul>
 * <li>Redistributions of source code must retain the above copyright notice, this list of conditions and
 *     the following disclaimer.</li>
 * <li>The authors and companies name may not be used to endorse or promote products derived from this
 *     software without specific prior written permission.</li>
 * </ul>
 * <br/>
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { UFQueueableAction } from "./UFQueueableAction";
import { UFProgressTools } from "../tools/UFProgressTools";
import { UFCancellationTokenSource } from "./UFCancellationTokenSource";
import { UFText } from "../tools/UFText";
// endregion
// region exports
/**
 * {@link UFParallelQueueAction} implements an action queue that can run a number of {@link IUFQueueableAction} actions
 * at the same time.
 *
 * The class extends {@link UFQueueableAction} so the queue can be placed into other queues if needed.
 */
export class UFParallelQueueAction extends UFQueueableAction {
    // endregion
    // region public methods
    /**
     * Constructs an instance of {@link UFParallelQueueAction} that will run a certain number of {@link UFQueueableAction}
     * at the same time.
     *
     * @param aConcurrentCount
     *   Maximum number of actions that should run at the same time.
     * @param anActions
     *   One or more actions to run
     */
    constructor(aConcurrentCount, ...anActions) {
        super();
        /**
         * Current promises being resolved.
         *
         * Since `Promise.race` does return the result of a promise, store the promises together with the index of
         * the action. The promise should return the same index value, so it can be removed from the map once it has finished.
         *
         * @private
         */
        this.m_activePromises = new Map();
        /**
         * Sum of progress weight of all actions that have finished.
         *
         * @private
         */
        this.m_doneProgressWeight = 0.0;
        /**
         * Points to the current action being processed
         *
         * @private
         */
        this.m_actionIndex = 0;
        /**
         * Combines the error messages generated by the actions.
         *
         * @private
         */
        this.m_errorMessage = '';
        this.m_actions = anActions;
        this.m_concurrentCount = aConcurrentCount;
        this.m_totalProgressWeight = anActions.reduce((previous, current) => previous + UFProgressTools.getProgressWeight(current), 0);
    }
    /**
     * Runs all stored actions at the same time.
     *
     * If the queue is already running, the method just returns true.
     *
     * @param aToken
     *   Token that can be cancelled to stop running.
     *
     * @return true if all actions run successful; false if one of the actions returned false or the token was cancelled.
     *
     * @throws an error if one or more actions threw an error.
     */
    run(aToken) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.running) {
                return true;
            }
            this.m_doneProgressWeight = 0.0;
            this.m_actionIndex = 0;
            this.m_errorMessage = '';
            const tokenSource = new UFCancellationTokenSource(aToken);
            yield this.runActions(tokenSource);
            // success if no task did cancel or threw an exception
            const result = !tokenSource.isCancellationRequested;
            // throw an exception if one or more actions threw an exception
            if (this.m_errorMessage.length) {
                throw new Error(`One or more actions raised an error: ${this.m_errorMessage}`);
            }
            return result;
        });
    }
    /**
     * Gets all current running actions.
     */
    getRunningActions() {
        const result = [];
        this.m_activePromises.forEach((promise, index) => {
            result.push(this.m_actions[index]);
        });
        return result;
    }
    // endregion
    // region public properties
    /**
     * True if the queue still has at least one running action.
     */
    get running() {
        return this.m_activePromises.size > 0;
    }
    /**
     * Number of running actions.
     */
    get runningCount() {
        return this.m_activePromises.size;
    }
    // endregion
    // region IUFProgress
    /**
     * Gets the progress, include the progress of any running action.
     */
    get progress() {
        let progressSum = 0;
        this.m_activePromises.forEach((value, index) => {
            const action = this.m_actions[index];
            progressSum += UFProgressTools.getProgressWeight(action) * UFProgressTools.getProgress(action);
        });
        return (progressSum + this.m_doneProgressWeight) / this.m_totalProgressWeight;
    }
    // endregion
    // region protected methods
    // endregion
    // region private methods
    /**
     * Starts running actions until all actions have finished running or the token is requesting cancellation.
     *
     * @param aTokenSource
     *   Will be cancelled if an action returned false or generated an error.
     *
     * @private
     */
    runActions(aTokenSource) {
        return __awaiter(this, void 0, void 0, function* () {
            // keep looping if there are actions that still can be added or if there are any active actions still running
            while ((!aTokenSource.isCancellationRequested && (this.m_actionIndex < this.m_actions.length)) ||
                (this.m_activePromises.size > 0)) {
                this.addPromises(aTokenSource);
                yield this.waitForPromiseToFinish();
            }
        });
    }
    /**
     * Waits for one of the active promises to resolve. The resolved promise will be removed from the active promises
     * list.
     *
     * @private
     */
    waitForPromiseToFinish() {
        return __awaiter(this, void 0, void 0, function* () {
            const index = yield Promise.race(Array.from(this.m_activePromises.values()));
            this.m_activePromises.delete(index);
        });
    }
    /**
     * Keep adding promises from {@link runAction} to the active list until the concurrent maximum is reached or there are
     * no more actions or the token is requesting a cancellation.
     *
     * @param aTokenSource
     */
    addPromises(aTokenSource) {
        while (!aTokenSource.isCancellationRequested
            && (this.m_actionIndex < this.m_actions.length)
            && (this.m_activePromises.size < this.m_concurrentCount)) {
            this.m_activePromises.set(this.m_actionIndex, this.runAction(this.m_actionIndex, aTokenSource));
            this.m_actionIndex++;
        }
    }
    /**
     * Runs an action. If the action returned false or threw an exception, call cancel on the token source.
     *
     * The returned promise will always resolve and never reject.
     *
     * @param anIndex
     *   Index to running action
     * @param aTokenSource
     *   Token source that will be cancelled if an error occurred or action returned false.
     *
     * @return a promise that will return the index of the action (same value as anIndex)
     *
     * @private
     */
    runAction(anIndex, aTokenSource) {
        return __awaiter(this, void 0, void 0, function* () {
            const action = this.m_actions[anIndex];
            let actionResult;
            try {
                actionResult = yield action.run(aTokenSource.token);
            }
            catch (error) {
                // an error results in a running failure
                actionResult = false;
                this.m_errorMessage = UFText.append(this.m_errorMessage, `${error.name}: ${error.message}`, ',');
            }
            // request cancellation if the action did not run successful
            if (!actionResult) {
                aTokenSource.cancel();
            }
            else {
                this.m_doneProgressWeight += UFProgressTools.getProgressWeight(action);
            }
            return anIndex;
        });
    }
}
// endregion
//# sourceMappingURL=UFParallelQueueAction.js.map