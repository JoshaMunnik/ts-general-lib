/**
 * @author Josha Munnik
 * @copyright Copyright (c) 2022 Ultra Force Development
 * @license
 * MIT License
 *
 * Copyright (c) 2022 Josha Munnik
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import { IUFQueueableAction } from "./IUFQueueableAction.js";
import { UFQueueableAction } from "./UFQueueableAction.js";
import { IUFCancellationToken } from "./IUFCancellationToken.js";
/**
 * {@link UFParallelQueueAction} implements an action queue that can run a number of {@link IUFQueueableAction} actions
 * at the same time.
 *
 * The class extends {@link UFQueueableAction} so the queue can be placed into other queues if needed.
 */
export declare class UFParallelQueueAction extends UFQueueableAction {
    /**
     * Actions list
     *
     * @private
     */
    private readonly m_actions;
    /**
     * Current promises being resolved.
     *
     * Since `Promise.race` does return the result of a promise, store the promises together with the index of
     * the action. The promise should return the same index value, so it can be removed from the map once it has finished.
     *
     * @private
     */
    private readonly m_activePromises;
    /**
     * Maximum number of actions to run concurrently.
     *
     * @private
     */
    private readonly m_concurrentCount;
    /**
     * Total progress weight of all actions.
     *
     * @private
     */
    private readonly m_totalProgressWeight;
    /**
     * Sum of progress weight of all actions that have finished.
     *
     * @private
     */
    private m_doneProgressWeight;
    /**
     * Points to the current action being processed
     *
     * @private
     */
    private m_actionIndex;
    /**
     * Combines the error messages generated by the actions.
     *
     * @private
     */
    private m_errorMessage;
    /**
     * Constructs an instance of {@link UFParallelQueueAction} that will run a certain number of {@link UFQueueableAction}
     * at the same time.
     *
     * @param aConcurrentCount
     *   Maximum number of actions that should run at the same time.
     * @param anActions
     *   One or more actions to run
     */
    constructor(aConcurrentCount: number, ...anActions: IUFQueueableAction[]);
    /**
     * Runs all stored actions at the same time.
     *
     * If the queue is already running, the method just returns true.
     *
     * @param aToken
     *   Token that can be cancelled to stop running.
     *
     * @return true if all actions run successful; false if one of the actions returned false or the token was cancelled.
     *
     * @throws an error if one or more actions threw an error.
     */
    run(aToken: IUFCancellationToken): Promise<boolean>;
    /**
     * Gets all current running actions.
     */
    getRunningActions(): IUFQueueableAction[];
    /**
     * True if the queue still has at least one running action.
     */
    get running(): boolean;
    /**
     * Number of running actions.
     */
    get runningCount(): number;
    /**
     * Gets the progress, include the progress of any running action.
     */
    get progress(): number;
    /**
     * Starts running actions until all actions have finished running or the token is requesting cancellation.
     *
     * @param aTokenSource
     *   Will be cancelled if an action returned false or generated an error.
     *
     * @private
     */
    private runActions;
    /**
     * Waits for one of the active promises to resolve. The resolved promise will be removed from the active promises
     * list.
     *
     * @private
     */
    private waitForPromiseToFinish;
    /**
     * Keep adding promises from {@link runAction} to the active list until the concurrent maximum is reached or there are
     * no more actions or the token is requesting a cancellation.
     *
     * @param aTokenSource
     */
    private addPromises;
    /**
     * Runs an action. If the action returned false or threw an exception, call cancel on the token source.
     *
     * The returned promise will always resolve and never reject.
     *
     * @param anIndex
     *   Index to running action
     * @param aTokenSource
     *   Token source that will be cancelled if an error occurred or action returned false.
     *
     * @return a promise that will return the index of the action (same value as anIndex)
     *
     * @private
     */
    private runAction;
}
