/**
 * @version 1
 * @author Josha Munnik
 * @copyright Copyright (c) 2022 Ultra Force Development
 * @license
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * <ul>
 * <li>Redistributions of source code must retain the above copyright notice, this list of conditions and
 *     the following disclaimer.</li>
 * <li>The authors and companies name may not be used to endorse or promote products derived from this
 *     software without specific prior written permission.</li>
 * </ul>
 * <br/>
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS´´ AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
import { IUFQueueableAction } from "./IUFQueueableAction";
import { UFQueueableAction } from "./UFQueueableAction";
import { IUFCancellationToken } from "./IUFCancellationToken";
/**
 * {@link UFParallelQueueAction} implements an action queue that can run a number of {@link IUFQueueableAction} actions
 * at the same time.
 *
 * The class extends {@link UFQueueableAction} so the queue can be placed into other queues if needed.
 */
export declare class UFParallelQueueAction extends UFQueueableAction {
    /**
     * Actions list
     *
     * @private
     */
    private readonly m_actions;
    /**
     * Current promises being resolved.
     *
     * Since `Promise.race` does return the result of a promise, store the promises together with the index of
     * the action. The promise should return the same index value, so it can be removed from the map once it has finished.
     *
     * @private
     */
    private readonly m_activePromises;
    /**
     * Maximum number of actions to run concurrently.
     *
     * @private
     */
    private readonly m_concurrentCount;
    /**
     * Total progress weight of all actions.
     *
     * @private
     */
    private readonly m_totalProgressWeight;
    /**
     * Sum of progress weight of all actions that have finished.
     *
     * @private
     */
    private m_doneProgressWeight;
    /**
     * Points to the current action being processed
     *
     * @private
     */
    private m_actionIndex;
    /**
     * Combines the error messages generated by the actions.
     *
     * @private
     */
    private m_errorMessage;
    /**
     * Constructs an instance of {@link UFParallelQueueAction} that will run a certain number of {@link UFQueueableAction}
     * at the same time.
     *
     * @param aConcurrentCount
     *   Maximum number of actions that should run at the same time.
     * @param anActions
     *   One or more actions to run
     */
    constructor(aConcurrentCount: number, ...anActions: IUFQueueableAction[]);
    /**
     * Runs all stored actions at the same time.
     *
     * If the queue is already running, the method just returns true.
     *
     * @param aToken
     *   Token that can be cancelled to stop running.
     *
     * @return true if all actions run successful; false if one of the actions returned false or the token was cancelled.
     *
     * @throws an error if one or more actions threw an error.
     */
    run(aToken: IUFCancellationToken): Promise<boolean>;
    /**
     * Gets all current running actions.
     */
    getRunningActions(): IUFQueueableAction[];
    /**
     * True if the queue still has at least one running action.
     */
    get running(): boolean;
    /**
     * Number of running actions.
     */
    get runningCount(): number;
    /**
     * Gets the progress, include the progress of any running action.
     */
    get progress(): number;
    /**
     * Starts running actions until all actions have finished running or the token is requesting cancellation.
     *
     * @param aTokenSource
     *   Will be cancelled if an action returned false or generated an error.
     *
     * @private
     */
    private runActions;
    /**
     * Waits for one of the active promises to resolve. The resolved promise will be removed from the active promises
     * list.
     *
     * @private
     */
    private waitForPromiseToFinish;
    /**
     * Keep adding promises from {@link runAction} to the active list until the concurrent maximum is reached or there are
     * no more actions or the token is requesting a cancellation.
     *
     * @param aTokenSource
     */
    private addPromises;
    /**
     * Runs an action. If the action returned false or threw an exception, call cancel on the token source.
     *
     * The returned promise will always resolve and never reject.
     *
     * @param anIndex
     *   Index to running action
     * @param aTokenSource
     *   Token source that will be cancelled if an error occurred or action returned false.
     *
     * @return a promise that will return the index of the action (same value as anIndex)
     *
     * @private
     */
    private runAction;
}
